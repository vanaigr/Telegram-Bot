datasource db {
  provider = "postgres"
}

generator tables {
  provider = "node ./src/db/tableGenerator.ts"
  output = "./tables.ts"
}

enum messageType {
    user
    assistant
}

model messages {
    chatId BigInt
    messageId BigInt

    date DateTime @db.Timestamp(6)
    type messageType
    raw Json

    @@id([chatId, messageId])
}

model reactions {
    chatId BigInt
    messageId BigInt
    hash String

    raw Json

    @@id([chatId, messageId, hash])
}

model messagesBackup {
    sequenceNumber Int @id @default(autoincrement())

    chatId BigInt
    messageId BigInt

    date DateTime @db.Timestamp(6)
    type messageType
    raw Json
}

model responses {
    sequenceNumber Int @id @default(autoincrement())
    raw Json
    respondsToChatId BigInt
    respondsToMessageId BigInt
}

model postFilterResponses {
    sequenceNumber Int @id @default(autoincrement())
    raw Json
    respondsToChatId BigInt
    respondsToMessageId BigInt
}

model chatFullInfo {
    id BigInt @id
    updatedAt DateTime @db.Timestamp(6)
    raw Json
}

enum downloadStatus {
    downloading
    error
    done
}

model photos {
    chatId BigInt
    // Not sure if it's globally unique or not. In any case we query them by
    // chat, and it's easier to store chat id with it even if it may be duplicated now.
    fileUniqueId String @db.VarChar(512)

    raw Json
    status downloadStatus
    bytes Bytes
    downloadStartDate DateTime @db.Timestamp(6)

    @@id([chatId, fileUniqueId])
}

// Locks `responses` for that chat
model chatLocks {
    id BigInt @id
}

// separate from chats since how will you add a chat otherwise?
model chatWhitelist {
    id BigInt @id
    enabled Boolean @default(true)
}

model debug {
    sequenceNumber Int @id @default(autoincrement())
    raw Json
    createdAt DateTime @db.Timestamp(6) @default(now())
}
